---
title: "【AITL】AITL Silicon Pathway #2：FSM を Python から Verilog RTL に落とす"
emoji: "🧠"
type: "tech"
topics: ["ASIC", "Verilog", "FSM", "OpenLane", "制御"]
---

# AITL Silicon Pathway #2  
## FSM を Python から Verilog RTL に落とすということ

前回（Chapter1）では、FSM（有限状態機械）を **Python で設計する**ところまでを扱いました。  
今回は一歩進めて、その FSM を **Verilog RTL としてハードウェアに落とす**までを整理します。

ただし、いきなり RTL を書く話ではありません。

本稿のテーマは、

> **FSM を「ハードウェア化できる仕様」に変換するとはどういうことか**

です。

---

## なぜ FSM を形式化する必要があるのか

Python で書いた FSM は非常に柔軟です。

- if / elif による分岐
- 状態を文字列や enum で表現できる
- 暗黙の条件分岐や例外処理も書ける

しかし、そのままでは **ハードウェアにはなりません**。

RTL に落とすためには、FSM は次の性質を満たす必要があります。

- 状態が有限で固定されている
- すべての入力条件に対して遷移が定義されている
- 振る舞いが完全に決定論的
- クロック境界が明確である

つまり、

> **「動けばよい FSM」から「仕様として固定された FSM」へ**

一段階、抽象度を下げる必要があります。

---

## AITL における FSM の役割

AITL は、以下の三層構造を前提としています。

LLM（外側）
└ 異常検知・再設計・方針決定

FSM（中間）
└ モード管理・状態遷移・制御方針切替

PID（内側）
└ 実時間制御（V–I 応答の安定化）


このうち FSM は、

- LLM の判断結果を入力条件として受け取り
- PID の制御モードを状態遷移として切り替える

という **離散的かつ決定論的な制御層**です。

そのため FSM は、  
**ソフトウェアよりもハードウェアとして固定する価値が高い**  
という位置づけになります。

---

## Python FSM と RTL FSM の決定的な違い

Python の FSM と RTL の FSM は、本質的に別物です。

### Python FSM
- 実行順序で意味が決まる
- 条件の抜けや曖昧さが許される
- 状態表現が暗黙的

### RTL FSM
- 並列回路として解釈される
- すべての状態・入力に意味が必要
- 状態はビット列として表現される

このギャップを埋めるために必要なのが、  
**形式化された FSM 仕様**です。

---

## FSM を「表」に落とす

Chapter2 では、FSM を以下の要素に分解します。

- 状態表（State Table）
- 遷移表（Transition Table）
- 入力信号定義
- 出力信号定義

たとえば、

- IDLE
- INIT
- RUN
- FAULT
- RECOVER

といった状態を明示的に列挙し、

- どの状態で  
- どの条件のときに  
- 次にどの状態へ遷移するか  

を **すべて表として定義**します。

この段階で、

> 「書いていない場合どうなるのか？」

という曖昧さは許されません。  
**未定義の遷移は存在しない遷移**です。

---

## Python → Verilog の写像ルールを作る

次に必要なのは、

> Python の FSM をどう RTL に翻訳するか

という **写像ルールの明文化**です。

例を挙げると：

- Python の状態 → Verilog の `localparam`
- if 条件 → 組合せ論理
- 状態更新 → クロック同期レジスタ
- 出力 → Moore 型（状態依存）

これらを **人の感覚ではなく、文章として固定**します。

これにより、

- 書く人が変わっても
- 時間が経っても

同じ FSM から同じ RTL が生成されるようになります。

---

## RTL は「結果」であって「本質」ではない

よくある誤解があります。

> FSM 設計 ＝ RTL を書くこと

これは半分しか正しくありません。

本質は、

- 状態とは何か
- 遷移条件は何か
- 仕様が矛盾なく定義されているか

であり、  
RTL は **その結果として現れる表現**に過ぎません。

Chapter2 ではスケルトン RTL と完全版 RTLを示していますが、  
重要なのは **そこに至る思考プロセス**です。

---

## OpenLane を前提にした FSM RTL の勘所

ASIC を前提にすると、FSM RTL には現実的な制約があります。

- 状態エンコードは明示する
- `always` ブロックの役割を混ぜない
- ラッチを絶対に作らない
- `default` 分岐を必ず書く

これらは「お作法」ではなく、  
**合成結果を安定させるための実務ルール**です。

Chapter2 の RTL は、  
OpenLane（Yosys）で破綻しないことを前提に設計されています。

---

## Chapter2 のまとめ

この章でやったことを一言で言うと、

> **FSM を「考え方」から「仕様」に落とした**

ということです。

- Python FSM を直接 RTL にしない
- いったん形式化する
- ルールを定義する
- その結果として RTL を書く

この順序を守ることで、FSM は  
**再利用可能な設計資産**になります。

---

## 次回（Chapter3）予告

次の Chapter3 では、

- FSM RTL のシミュレーション
- OpenLane による合成
- ASIC フローに流すと何が起きるか

を扱う予定です。

FSM が **本当にハードウェアとして成立するか**を  
検証するフェーズに進みます。

---

ここまでお読みいただき、ありがとうございました。


